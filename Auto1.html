<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Аутентификация соединений с сервером. Авторизация логинов для подключения к базам данных</h1>
      <h2>Аутентификация vs. Авторизация: Краткое различие</h2>
        <ul>
            <li><b>Аутентификация (Authentication - AuthN):</b> Процесс <b>проверки подлинности</b> пользователя. Ответ на вопрос "Кто вы?". Это проверка логина/пароля, отпечатка пальца, Face ID и т.д.</li>
            <li><b>Авторизация (Authorization - AuthZ):</b> Процесс <b>проверки прав</b> пользователя на выполнение определенных действий. Ответ на вопрос <b>"Что вам разрешено делать?"</b>. Это проверка ролей (админ, модератор, пользователь) и разрешений (может ли он читать, писать, удалять).</li>
        </ul>
        <p><b>Простая аналогия:</b></p>
        <ol>
            <li>Вы предъявляете паспорт на ресепшене отеля -> <b>Аутентификация</b> (доказали, что вы это вы).</li>
            <li>Вам выдают ключ от номера 505, но не от номера 506 -> <b>Авторизация</b> (определили, к чему у вас есть доступ).</li>
        </ol>
      <h2>Часть 1: Аутентификация соединений с сервером</h2>
        <p>Здесь речь идет о том, как <b>ваше веб-приложение (клиент)</b> доказывает свою подлинность <b>серверу</b>, на котором работает backend. Это особенно важно для API.</p>
        <h3>Распространенные методы аутентификации сервер-сервер или клиент-сервер:</h3>
          <ol>
            <li><b>API Keys (Ключи API)</b>
                <ul>
                    <li><b>Как работает:</b> Простой длинный уникальный токен, который клиент передает с каждым запросом (обычно в заголовке X-API-Key или как параметр запроса).</li>
                    <li><b>Плюсы:</b> Простота реализации и использование.</li>
                    <li><b>Минусы:</b> Низкая безопасность. Ключ часто передается открыто, его компрометация дает полный доступ. <b>Никогда не используйте для аутентификации пользователей!</b> Подходит для аутентификации сервисов между собой в доверенной среде.</li>
                </ul>
            </li><br>
            <li><b>JWT (JSON Web Tokens)</b>
                <p><b>Как работает:</b></p>
                <ol>
                    <li>Пользователь логинится (отправляет логин/пароль).</li>
                    <li>Сервер проверяет данные, создает <b>JWT-токен</b> (подписанный цифровой подписью) и отдает его клиенту.</li>
                    <li>Клиент сохраняет токен (часто в LocalStorage или Cookies) и передает его в заголовке Authorization: Bearer <токен> при каждом последующем запросе.</li>
                    <li>Сервер проверяет подпись токена и извлекает из него данные (например, user id). <b>Ему не нужно хранить сессию на сервере</b> (stateless).</li>
                </ol>
                <p><ul>
                    <li><b>Плюсы:</b> Масштабируемость (не требует хранения сессий на сервере), удобство для мобильных и SPA-приложений.</li>
                    <li><b>Минусы:</b> Сложность с немедленной инвалидацией токена (пока не истечет его срок жизни).</li>
                </ul></p>
            </li>
            <li><b>OAuth 2.0 / OpenID Connect</b>
                <ul>
                    <li><b>Как работает:</b> Делегированная аутентификация. Пользователь аутентифицируется на доверенном сервисе (например, Google, GitHub, Facebook), который затем выдает вашему приложению токен доступа.</li>
                    <li><b>Плюсы:</b> Пользователям не нужно создавать новый пароль. Высокий уровень безопасности, так как пароли обрабатываются крупными провайдерами.</li>
                    <li><b>Минусы:</b> Более сложная реализация на стороне backend.</li>
                </ul>
            </li><br>
            <li><b>Аутентификация на основе сессий (Cookies)</b>
                <p><b>Как работает:</b></p>
                <ol>
                    <li>Пользователь логинится.</li>
                    <li>Сервер создает запись сессии в базе данных или in-memory хранилище (например, Redis) и отправляет клиенту идентификатор сессии (Session ID) в cookie (с флагами HttpOnly, Secure).</li>
                    <li>Браузер автоматически отправляет этот cookie с каждым запросом.</li>
                    <li>Сервер проверяет ID сессии в своем хранилище.</li>
                </ol>
                <p><ul>
                    <li><b>Плюсы:</b> Простота инвалидации сессии (удалил запись — доступ закрыт). Безопаснее хранения JWT в LocalStorage.</li>
                    <li><b>Минусы:</b> Требует stateful-сервера и хранения сессий, что может усложнить масштабирование.</li>
                </ul></p>
            </li>
            </ol>
    <h2>Часть 2: Авторизация логинов для подключения к базам данных</h2>
      <p>Здесь речь идет о том, как <b>ваше backend-приложение</b> подключается к <b>СУБД</b> (MySQL, PostgreSQL, MongoDB и т.д.). Это служебная, а не пользовательская авторизация.</p>
      <p><b>Ключевые принципы:</b></p>
      <ol>
        <li><b>Принцип наименьших привилегий (Principle of Least Privilege)</b>
            <ul>
                <li>Это золотое правило. Учетная запись, которую использует ваше приложение для подключения к БД, должна иметь <b>ровно те права, которые ей необходимы, и не более.</b></li>
                <li><b>Пример:</b> Если ваше приложение только читает данные из таблицы articles, его пользователь БД должен иметь право только SELECT на эту таблицу, но не INSERT, UPDATE, DELETE или DROP.</li>
            </ul>
        </li><br>
        <li><b>Использование разных учетных записей для разных целей</b>
            <ul>
                <li>Не используйте одну супер-учетку (root/admin) для всего.</li>
                <li>Создайте отдельного пользователя БД специально для вашего приложения.</li>
                <li>Для разных сервисов (основное приложение, скрипты миграции, analytics) можно создать разных пользователей с разными правами.</li>
            </ul>
        </li><br>
        <li><b>Безопасное хранение учетных данных</b>
            <ul>
                <li><b>Никогда не храните логины/пароли от БД в коде приложения (в гите)!</b></li>
                <li><b>Используйте переменные окружения (Environment Variables) или секреты (Secrets):</b>
                    <ul>
                        <li>Локально: файл .env (который добавлен в .gitignore).</li>
                        <li>На продакшене: используйте механизмы вашего хостинга/платформы (Environment Variables в Heroku, Secrets в Kubernetes, AWS Secrets Manager, HashiCorp Vault).</li>
                    </ul>
                </li>
                <li>Пример для Node.js и .env:<br>
                    bash<br>
# Файл .env<br>
DB_HOST=localhost<br>
DB_PORT=5432<br>
DB_NAME=mydatabase<br>
DB_USER=myapp_user<br>
DB_PASSWORD=very_strong_password_123<br>
javascript<br>
// Код приложения<br>
const { Pool } = require('pg');<br>
const pool = new Pool({<br>
  host: process.env.DB_HOST,<br>
  port: process.env.DB_PORT,<br>
  database: process.env.DB_NAME,<br>
  user: process.env.DB_USER,<br>
  password: process.env.DB_PASSWORD,<br>
});<br>

                </li>
            </ul>
        </li>
        <li><p><b>Использование SSL/TLS для подключения к БД</b>
            <ul>
                <li>Особенно критично, если ваша БД находится на удаленном сервере (не на том же хосте, что и приложение).</li>
                <li>Это шифрует весь трафик между приложением и СУБД, защищая данные от перехвата.</li>
            </ul>
        </li></p>
      </ol>
</body>
</html>